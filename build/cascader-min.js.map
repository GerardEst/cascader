{
  "version": 3,
  "sources": ["../src/cascader.ts"],
  "sourcesContent": ["let container_width: number\r\nlet rows: number\r\nlet cols: number\r\nlet vertical_gap: number\r\nlet horizontal_gap: number\r\nlet minWidth: number\r\nlet container: HTMLElement | null\r\nlet bricks: any\r\n\r\ntype CascadeContainer = string | HTMLElement\r\nexport interface CascadeOptions {\r\n  minWidth: number,\r\n  gap?: number,\r\n  verticalGap?: number,\r\n  horizontalGap?: number\r\n}\r\n\r\nlet resizeObserver = new ResizeObserver( () => {\r\n  init()\r\n})\r\n\r\nexport function cascade(container_container: CascadeContainer, options: CascadeOptions){\r\n  \r\n  horizontal_gap = options.horizontalGap || options.gap || 20\r\n  vertical_gap = options.verticalGap || options.gap || 20\r\n  minWidth = options.minWidth || 200\r\n\r\n  container = typeof container_container === 'string' ? document.querySelector(container_container) : container_container\r\n  container_width = container!.offsetWidth\r\n  cols = Math.floor(container_width / minWidth)\r\n\r\n  bricks = container!.children // Esto seguro que es una HTMLCollection\r\n\r\n  container!.style.position = 'relative'\r\n\r\n  init()\r\n}\r\n  \r\nfunction init(){\r\n  positionBricks()\r\n  setContainerHeight()\r\n}\r\n\r\nexport function removeCascade(){  \r\n  resizeObserver.disconnect()\r\n  container!.removeAttribute('style')\r\n  for(let brick of bricks) brick.removeAttribute('style')\r\n}\r\n\r\nfunction positionBricks(){\r\n  for(let i=0; i<bricks.length; i++){\r\n    \r\n    // Recalculate container_width when resize and redistribute columns\r\n    container_width = container!.offsetWidth\r\n    cols = Math.floor(container_width / minWidth)\r\n\r\n    const brick:HTMLElement = bricks[i] // Typescript cree que bricks[i] es un Element. bricks es HTMLCollection. \r\n    //Tengo que decirle que lo de dentro no son Element sino HTMLElement, pero no me deja hacer HTMLCollectionOf\r\n\r\n    const brick_row:number = Math.floor(i/cols)\r\n    const brick_col:number = i%cols\r\n    const brick_width:number = 100/cols\r\n    const gap_reduce:number = horizontal_gap*(cols-1)/cols\r\n    if(brick_row > rows) rows = brick_row\r\n\r\n    brick.style.position = 'absolute'\r\n    brick.setAttribute('row', `${brick_row}`)\r\n    brick.setAttribute('col', `${brick_col}`)\r\n\r\n    // Horizontal positioning\r\n    brick.style.width = `calc(${brick_width}% - ${gap_reduce}px)`\r\n    brick.style.left = `calc(${brick_width*brick_col}% + ${horizontal_gap/cols * brick_col}px`\r\n\r\n    // Vertical positioning: sume of the precedent bricks in the column \r\n    const bricks_in_col = container!.querySelectorAll(`[col='${brick_col}']`)\r\n    let brick_column_height = 0\r\n\r\n    for(let brick_in_col of bricks_in_col){\r\n      if(Number(brick_in_col.getAttribute('row')) > brick_row) continue\r\n      brick_column_height = brick_column_height + brick_in_col.offsetHeight + vertical_gap\r\n    }\r\n\r\n    brick_column_height = brick_column_height - brick.offsetHeight - vertical_gap\r\n    brick.style.top = brick_column_height + 'px'\r\n\r\n    resizeObserver.observe(brick)\r\n    \r\n  }\r\n}\r\n\r\n// Check the size of largest column and resize the cascade container\r\n// TODO -> Seguro que esto se puede hacer aprovechando los otros loops\r\nfunction setContainerHeight(){\r\n  let largest_col = 0\r\n  \r\n  for(let i=0; i<cols; i++){\r\n    const col = container!.querySelectorAll(`[col='${i}']`)\r\n    \r\n    let total_height = 0\r\n    \r\n    for(let el of col){\r\n      let row = el.getAttribute('row')\r\n      let additional_gap = row < rows ? vertical_gap : 0\r\n      total_height = total_height + el.offsetHeight + additional_gap\r\n    }\r\n\r\n    if(total_height > largest_col) largest_col = total_height\r\n  }\r\n\r\n  container!.style.height = largest_col+'px'\r\n}"],
  "mappings": "AAAA,IAAIA,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAUAC,EAAiB,IAAI,eAAgB,IAAM,CAC7CC,EAAK,CACP,CAAC,EAEM,SAASC,EAAQC,EAAuCC,EAAwB,CAErFR,EAAiBQ,EAAQ,eAAiBA,EAAQ,KAAO,GACzDT,EAAeS,EAAQ,aAAeA,EAAQ,KAAO,GACrDP,EAAWO,EAAQ,UAAY,IAE/BN,EAAY,OAAOK,GAAwB,SAAW,SAAS,cAAcA,CAAmB,EAAIA,EACpGX,EAAkBM,EAAW,YAC7BJ,EAAO,KAAK,MAAMF,EAAkBK,CAAQ,EAE5CE,EAASD,EAAW,SAEpBA,EAAW,MAAM,SAAW,WAE5BG,EAAK,CACP,CAEA,SAASA,GAAM,CACbI,EAAe,EACfC,EAAmB,CACrB,CAEO,SAASC,GAAe,CAC7BP,EAAe,WAAW,EAC1BF,EAAW,gBAAgB,OAAO,EAClC,QAAQU,KAAST,EAAQS,EAAM,gBAAgB,OAAO,CACxD,CAEA,SAASH,GAAgB,CACvB,QAAQI,EAAE,EAAGA,EAAEV,EAAO,OAAQU,IAAI,CAGhCjB,EAAkBM,EAAW,YAC7BJ,EAAO,KAAK,MAAMF,EAAkBK,CAAQ,EAE5C,IAAMW,EAAoBT,EAAOU,GAG3BC,EAAmB,KAAK,MAAMD,EAAEf,CAAI,EACpCiB,EAAmBF,EAAEf,EACrBkB,EAAqB,IAAIlB,EACzBmB,EAAoBjB,GAAgBF,EAAK,GAAGA,EAC/CgB,EAAYjB,IAAMA,EAAOiB,GAE5BF,EAAM,MAAM,SAAW,WACvBA,EAAM,aAAa,MAAO,GAAGE,GAAW,EACxCF,EAAM,aAAa,MAAO,GAAGG,GAAW,EAGxCH,EAAM,MAAM,MAAQ,QAAQI,QAAkBC,OAC9CL,EAAM,MAAM,KAAO,QAAQI,EAAYD,QAAgBf,EAAeF,EAAOiB,MAG7E,IAAMG,EAAgBhB,EAAW,iBAAiB,SAASa,KAAa,EACpEI,EAAsB,EAE1B,QAAQC,KAAgBF,EACnB,OAAOE,EAAa,aAAa,KAAK,CAAC,EAAIN,IAC9CK,EAAsBA,EAAsBC,EAAa,aAAerB,GAG1EoB,EAAsBA,EAAsBP,EAAM,aAAeb,EACjEa,EAAM,MAAM,IAAMO,EAAsB,KAExCf,EAAe,QAAQQ,CAAK,CAE9B,CACF,CAIA,SAASF,GAAoB,CAC3B,IAAIW,EAAc,EAElB,QAAQR,EAAE,EAAGA,EAAEf,EAAMe,IAAI,CACvB,IAAMS,EAAMpB,EAAW,iBAAiB,SAASW,KAAK,EAElDU,EAAe,EAEnB,QAAQC,KAAMF,EAAI,CAEhB,IAAIG,EADMD,EAAG,aAAa,KAAK,EACJ3B,EAAOE,EAAe,EACjDwB,EAAeA,EAAeC,EAAG,aAAeC,CAClD,CAEGF,EAAeF,IAAaA,EAAcE,EAC/C,CAEArB,EAAW,MAAM,OAASmB,EAAY,IACxC",
  "names": ["container_width", "rows", "cols", "vertical_gap", "horizontal_gap", "minWidth", "container", "bricks", "resizeObserver", "init", "cascade", "container_container", "options", "positionBricks", "setContainerHeight", "removeCascade", "brick", "i", "brick_row", "brick_col", "brick_width", "gap_reduce", "bricks_in_col", "brick_column_height", "brick_in_col", "largest_col", "col", "total_height", "el", "additional_gap"]
}
