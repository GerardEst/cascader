{
  "version": 3,
  "sources": ["../src/cascader.ts"],
  "sourcesContent": ["let container_width = 0\r\nlet rows = 0\r\nlet cols = 0\r\nlet vertical_gap = 0\r\nlet horizontal_gap = 0\r\nlet minWidth = 0\r\nlet element = null\r\nlet bricks = null\r\n\r\nlet resizeObserver = new ResizeObserver( (entries) => {\r\n  init()\r\n})\r\n\r\nexport function cascade(container_element, options){\r\n\r\n    horizontal_gap = options.horizontalGap || options.gap || 20\r\n    vertical_gap = options.verticalGap || options.gap || 20\r\n    minWidth = options.minWidth || 200\r\n    element = typeof container_element === 'string' ? document.querySelector(container_element) : container_element\r\n    container_width = element.offsetWidth\r\n    cols = Math.floor(container_width / minWidth)\r\n\r\n    // TODO -> Com que nom\u00E9s ID?? Que es pugui amb classes tamb\u00E9 home. \r\n    // TODO -> si hi ha un error, que no bloquegi el js de la pagina\r\n    if(!element.id) console.error('Cascader: Container needs an id')\r\n\r\n    bricks = document.querySelectorAll(`#${element.id} > *`)\r\n\r\n    element.style.position = 'relative'\r\n\r\n    init()\r\n}\r\n  \r\nfunction init(){\r\n  positionBricks()\r\n  setContainerHeight()\r\n}\r\n\r\nexport function removeCascade(){  \r\n  resizeObserver.disconnect()\r\n  element.removeAttribute('style')\r\n  for(let brick of bricks) brick.removeAttribute('style')\r\n}\r\n\r\nfunction positionBricks(){\r\n  for(let i=0; i<bricks.length; i++){\r\n    \r\n    // Recalculate container_width when resize and redistribute columns\r\n    container_width = element.offsetWidth\r\n    cols = Math.floor(container_width / minWidth)\r\n\r\n    const brick = bricks[i]\r\n\r\n    const brick_row = Math.floor(i/cols)\r\n    const brick_col = i%cols\r\n    const brick_width = 100/cols\r\n    const gap_reduce = horizontal_gap*(cols-1)/cols\r\n    if(brick_row > rows) rows = brick_row\r\n\r\n    brick.style.position = 'absolute'\r\n    brick.setAttribute('row', brick_row)\r\n    brick.setAttribute('col', brick_col)\r\n\r\n    // Horizontal positioning\r\n    brick.style.width = `calc(${brick_width}% - ${gap_reduce}px)`\r\n    brick.style.left = `calc(${brick_width*brick_col}% + ${horizontal_gap/cols * brick_col}px`\r\n\r\n    // Vertical positioning: sume of the precedent bricks in the column \r\n    const bricks_in_col = element.querySelectorAll(`[col='${brick_col}']`)\r\n    let brick_column_height = 0\r\n\r\n    for(let brick_in_col of bricks_in_col){\r\n      if(brick_in_col.getAttribute('row') > brick_row) continue\r\n      brick_column_height = brick_column_height + brick_in_col.offsetHeight + vertical_gap\r\n    }\r\n\r\n    brick_column_height = brick_column_height - brick.offsetHeight - vertical_gap\r\n    brick.style.top = brick_column_height + 'px'\r\n\r\n    resizeObserver.observe(brick)\r\n    \r\n  }\r\n}\r\n\r\n// Check the size of largest column and resize the cascade container\r\n// TODO -> Seguro que esto se puede hacer aprovechando los otros loops\r\nfunction setContainerHeight(){\r\n  let largest_col = 0\r\n  \r\n  for(let i=0; i<cols; i++){\r\n    const col = element.querySelectorAll(`[col='${i}']`)\r\n    \r\n    let total_height = 0\r\n    \r\n    for(let el of col){\r\n      let row = el.getAttribute('row')\r\n      let additional_gap = row < rows ? vertical_gap : 0\r\n      total_height = total_height + el.offsetHeight + additional_gap\r\n    }\r\n\r\n    if(total_height > largest_col) largest_col = total_height\r\n  }\r\n\r\n  element.style.height = largest_col+'px'\r\n}"],
  "mappings": "AAAA,IAAIA,EAAkB,EAClBC,EAAO,EACPC,EAAO,EACPC,EAAe,EACfC,EAAiB,EACjBC,EAAW,EACXC,EAAU,KACVC,EAAS,KAETC,EAAiB,IAAI,eAAiBC,GAAY,CACpDC,EAAK,CACP,CAAC,EAEM,SAASC,EAAQC,EAAmBC,EAAQ,CAE/CT,EAAiBS,EAAQ,eAAiBA,EAAQ,KAAO,GACzDV,EAAeU,EAAQ,aAAeA,EAAQ,KAAO,GACrDR,EAAWQ,EAAQ,UAAY,IAC/BP,EAAU,OAAOM,GAAsB,SAAW,SAAS,cAAcA,CAAiB,EAAIA,EAC9FZ,EAAkBM,EAAQ,YAC1BJ,EAAO,KAAK,MAAMF,EAAkBK,CAAQ,EAIxCC,EAAQ,GAEZC,EAAS,SAAS,iBAAiB,IAAID,EAAQ,QAAQ,EAEvDA,EAAQ,MAAM,SAAW,WAEzBI,EAAK,CACT,CAEA,SAASA,GAAM,CACbI,EAAe,EACfC,EAAmB,CACrB,CAEO,SAASC,GAAe,CAC7BR,EAAe,WAAW,EAC1BF,EAAQ,gBAAgB,OAAO,EAC/B,QAAQW,KAASV,EAAQU,EAAM,gBAAgB,OAAO,CACxD,CAEA,SAASH,GAAgB,CACvB,QAAQI,EAAE,EAAGA,EAAEX,EAAO,OAAQW,IAAI,CAGhClB,EAAkBM,EAAQ,YAC1BJ,EAAO,KAAK,MAAMF,EAAkBK,CAAQ,EAE5C,IAAMY,EAAQV,EAAOW,GAEfC,EAAY,KAAK,MAAMD,EAAEhB,CAAI,EAC7BkB,EAAYF,EAAEhB,EACdmB,EAAc,IAAInB,EAClBoB,EAAalB,GAAgBF,EAAK,GAAGA,EACxCiB,EAAYlB,IAAMA,EAAOkB,GAE5BF,EAAM,MAAM,SAAW,WACvBA,EAAM,aAAa,MAAOE,CAAS,EACnCF,EAAM,aAAa,MAAOG,CAAS,EAGnCH,EAAM,MAAM,MAAQ,QAAQI,QAAkBC,OAC9CL,EAAM,MAAM,KAAO,QAAQI,EAAYD,QAAgBhB,EAAeF,EAAOkB,MAG7E,IAAMG,EAAgBjB,EAAQ,iBAAiB,SAASc,KAAa,EACjEI,EAAsB,EAE1B,QAAQC,KAAgBF,EACnBE,EAAa,aAAa,KAAK,EAAIN,IACtCK,EAAsBA,EAAsBC,EAAa,aAAetB,GAG1EqB,EAAsBA,EAAsBP,EAAM,aAAed,EACjEc,EAAM,MAAM,IAAMO,EAAsB,KAExChB,EAAe,QAAQS,CAAK,CAE9B,CACF,CAIA,SAASF,GAAoB,CAC3B,IAAIW,EAAc,EAElB,QAAQR,EAAE,EAAGA,EAAEhB,EAAMgB,IAAI,CACvB,IAAMS,EAAMrB,EAAQ,iBAAiB,SAASY,KAAK,EAE/CU,EAAe,EAEnB,QAAQC,KAAMF,EAAI,CAEhB,IAAIG,EADMD,EAAG,aAAa,KAAK,EACJ5B,EAAOE,EAAe,EACjDyB,EAAeA,EAAeC,EAAG,aAAeC,CAClD,CAEGF,EAAeF,IAAaA,EAAcE,EAC/C,CAEAtB,EAAQ,MAAM,OAASoB,EAAY,IACrC",
  "names": ["container_width", "rows", "cols", "vertical_gap", "horizontal_gap", "minWidth", "element", "bricks", "resizeObserver", "entries", "init", "cascade", "container_element", "options", "positionBricks", "setContainerHeight", "removeCascade", "brick", "i", "brick_row", "brick_col", "brick_width", "gap_reduce", "bricks_in_col", "brick_column_height", "brick_in_col", "largest_col", "col", "total_height", "el", "additional_gap"]
}
