{
  "version": 3,
  "sources": ["../src/cascader.js"],
  "sourcesContent": ["let container_width = 0\nlet rows = 0\nlet cols = 0\nlet vertical_gap = 0\nlet horizontal_gap = 0\nlet minWidth = 0\nlet element = null\nlet bricks = null\n\nlet resizeObserver = new ResizeObserver( (entries) => {\n  init()\n})\n\nexport function cascade(container_element, options){\n\n    horizontal_gap = options.horizontalGap || options.gap || 20\n    vertical_gap = options.verticalGap || options.gap || 20\n    minWidth = options.minWidth || 200\n    element = typeof container_element === 'string' ? document.querySelector(container_element) : container_element\n    container_width = element.offsetWidth\n    cols = Math.floor(container_width / minWidth)\n\n    // TODO -> Com que nom\u00E9s ID?? Que es pugui amb classes tamb\u00E9 home. \n    // TODO -> si hi ha un error, que no bloquegi el js de la pagina\n    if(!element.id) console.error('Cascader: Container needs an id')\n\n    bricks = document.querySelectorAll(`#${element.id} > *`)\n\n    element.style.position = 'relative'\n\n    init()\n}\n  \nfunction init(){\n  positionBricks()\n  setContainerHeight()\n}\n\nexport function removeCascade(){  \n  resizeObserver.disconnect()\n  element.removeAttribute('style')\n  for(let brick of bricks) brick.removeAttribute('style')\n}\n\nfunction positionBricks(){\n  for(let i=0; i<bricks.length; i++){\n    \n    // Recalculate container_width when resize and redistribute columns\n    container_width = element.offsetWidth\n    cols = Math.floor(container_width / minWidth)\n\n    const brick = bricks[i]\n\n    const brick_row = Math.floor(i/cols)\n    const brick_col = i%cols\n    const brick_width = 100/cols\n    const gap_reduce = horizontal_gap*(cols-1)/cols\n    if(brick_row > rows) rows = brick_row\n\n    brick.style.position = 'absolute'\n    brick.setAttribute('row', brick_row)\n    brick.setAttribute('col', brick_col)\n\n    // Horizontal positioning\n    brick.style.width = `calc(${brick_width}% - ${gap_reduce}px)`\n    brick.style.left = `calc(${brick_width*brick_col}% + ${horizontal_gap/cols * brick_col}px`\n\n    // Vertical positioning: sume of the precedent bricks in the column \n    const bricks_in_col = element.querySelectorAll(`[col='${brick_col}']`)\n    let brick_column_height = 0\n\n    for(let brick_in_col of bricks_in_col){\n      if(brick_in_col.getAttribute('row') > brick_row) continue\n      brick_column_height = brick_column_height + brick_in_col.offsetHeight + vertical_gap\n    }\n\n    brick_column_height = brick_column_height - brick.offsetHeight - vertical_gap\n    brick.style.top = brick_column_height + 'px'\n\n    resizeObserver.observe(brick)\n    \n  }\n}\n\n// Check the size of largest column and resize the cascade container\n// TODO -> Seguro que esto se puede hacer aprovechando los otros loops\nfunction setContainerHeight(){\n  let largest_col = 0\n  \n  for(let i=0; i<cols; i++){\n    const col = element.querySelectorAll(`[col='${i}']`)\n    \n    let total_height = 0\n    \n    for(let el of col){\n      let row = el.getAttribute('row')\n      let additional_gap = row < rows ? vertical_gap : 0\n      total_height = total_height + el.offsetHeight + additional_gap\n    }\n\n    if(total_height > largest_col) largest_col = total_height\n  }\n\n  element.style.height = largest_col+'px'\n}"],
  "mappings": "AAAA,IAAIA,EAAkB,EAClBC,EAAO,EACPC,EAAO,EACPC,EAAe,EACfC,EAAiB,EACjBC,EAAW,EACXC,EAAU,KACVC,EAAS,KAETC,EAAiB,IAAI,eAAiBC,GAAY,CACpDC,EAAK,CACP,CAAC,EAEM,SAASC,EAAQC,EAAmBC,EAAQ,CAE/CT,EAAiBS,EAAQ,eAAiBA,EAAQ,KAAO,GACzDV,EAAeU,EAAQ,aAAeA,EAAQ,KAAO,GACrDR,EAAWQ,EAAQ,UAAY,IAC/BP,EAAU,OAAOM,GAAsB,SAAW,SAAS,cAAcA,CAAiB,EAAIA,EAC9FZ,EAAkBM,EAAQ,YAC1BJ,EAAO,KAAK,MAAMF,EAAkBK,CAAQ,EAIxCC,EAAQ,GAEZC,EAAS,SAAS,iBAAiB,IAAID,EAAQ,QAAQ,EAEvDA,EAAQ,MAAM,SAAW,WAEzBI,EAAK,CACT,CAEA,SAASA,GAAM,CACbI,EAAe,EACfC,EAAmB,CACrB,CAEO,SAASC,GAAe,CAC7BR,EAAe,WAAW,EAC1BF,EAAQ,gBAAgB,OAAO,EAC/B,QAAQW,KAASV,EAAQU,EAAM,gBAAgB,OAAO,CACxD,CAEA,SAASH,GAAgB,CACvB,QAAQI,EAAE,EAAGA,EAAEX,EAAO,OAAQW,IAAI,CAGhClB,EAAkBM,EAAQ,YAC1BJ,EAAO,KAAK,MAAMF,EAAkBK,CAAQ,EAE5C,IAAMY,EAAQV,EAAOW,GAEfC,EAAY,KAAK,MAAMD,EAAEhB,CAAI,EAC7BkB,EAAYF,EAAEhB,EACdmB,EAAc,IAAInB,EAClBoB,EAAalB,GAAgBF,EAAK,GAAGA,EACxCiB,EAAYlB,IAAMA,EAAOkB,GAE5BF,EAAM,MAAM,SAAW,WACvBA,EAAM,aAAa,MAAOE,CAAS,EACnCF,EAAM,aAAa,MAAOG,CAAS,EAGnCH,EAAM,MAAM,MAAQ,QAAQI,QAAkBC,OAC9CL,EAAM,MAAM,KAAO,QAAQI,EAAYD,QAAgBhB,EAAeF,EAAOkB,MAG7E,IAAMG,EAAgBjB,EAAQ,iBAAiB,SAASc,KAAa,EACjEI,EAAsB,EAE1B,QAAQC,KAAgBF,EACnBE,EAAa,aAAa,KAAK,EAAIN,IACtCK,EAAsBA,EAAsBC,EAAa,aAAetB,GAG1EqB,EAAsBA,EAAsBP,EAAM,aAAed,EACjEc,EAAM,MAAM,IAAMO,EAAsB,KAExChB,EAAe,QAAQS,CAAK,CAE9B,CACF,CAIA,SAASF,GAAoB,CAC3B,IAAIW,EAAc,EAElB,QAAQR,EAAE,EAAGA,EAAEhB,EAAMgB,IAAI,CACvB,IAAMS,EAAMrB,EAAQ,iBAAiB,SAASY,KAAK,EAE/CU,EAAe,EAEnB,QAAQC,KAAMF,EAAI,CAEhB,IAAIG,EADMD,EAAG,aAAa,KAAK,EACJ5B,EAAOE,EAAe,EACjDyB,EAAeA,EAAeC,EAAG,aAAeC,CAClD,CAEGF,EAAeF,IAAaA,EAAcE,EAC/C,CAEAtB,EAAQ,MAAM,OAASoB,EAAY,IACrC",
  "names": ["container_width", "rows", "cols", "vertical_gap", "horizontal_gap", "minWidth", "element", "bricks", "resizeObserver", "entries", "init", "cascade", "container_element", "options", "positionBricks", "setContainerHeight", "removeCascade", "brick", "i", "brick_row", "brick_col", "brick_width", "gap_reduce", "bricks_in_col", "brick_column_height", "brick_in_col", "largest_col", "col", "total_height", "el", "additional_gap"]
}
